import { PassThrough, Readable, Transform, TransformCallback, Writable } from "stream";
import { vertex } from "./vertex";
import { _cindex, _cstep, _cstep_change, _findIndex } from "./utils/utils";
import { chunk } from "./vertex";
import { LineParser, LineStringifier, Memory } from "./memory_utils";
import { Transposer } from "./transpose";
import { logger } from "./utils/utils";

export class Mapper extends Transform{
    private waitings:{
        [id:number]:chunk[]
    } = {};

    private i:number|null = null;
    private j:number|null = null;
    private k:number|null = null;

    constructor(private firstId:number, private secondId:number){
        super({objectMode:true, highWaterMark:1});
        
        this.waitings[this.firstId] = [];        
        this.waitings[this.secondId] = [];                
    }

    _transform(d:chunk, e:BufferEncoding, next:TransformCallback){                        
        const data = JSON.parse(JSON.stringify(d));
        
        // finding i, j, k, output_shape
        if(!this.i || !this.j || !this.k){
            if(data.id == this.firstId){
                this.i = data.outer.shape[0];
                this.j = data.outer.shape[1];
            }
            else if(data.id == this.secondId){                
                this.k = data.outer.shape[1];
            }
        }
        
        // update waiting
        if(!this.i || !this.j|| !this.k){                        
            this.waitings[data.id].push(data);
            return next();            
        }

        if(this.i && this.j && this.k){ 
            this.push_res(data);
            
            if(this.waitings[this.firstId].length > 0 || this.waitings[this.secondId].length > 0){
                this.waitings[this.firstId].forEach(d => this.push_res(d))
                this.waitings[this.secondId].forEach(d => this.push_res(d))
                this.waitings[this.firstId].length = 0;
                this.waitings[this.secondId].length = 0;
            }
        }

        next();
    }

    push_res(data:chunk|any){
        if(this.i && this.j && this.k){
            // finding index
            let index = _findIndex(data.outer.shape, data.outer.step, data.index);            
    
            // mapping respectively
            const op_step = _cstep([this.i, this.k]);
            if(data.id == this.firstId){
                let [i, j] = index;                            
                for(let k = 0; k < this.k; k++){                    
                    let new_data = Object.assign({}, data);
                    new_data.index =  _cindex([i, k], op_step);
                    new_data.op_shape = [this.i, this.k];                    
                    new_data.tot_j = this.j;
                    new_data.j = j;

                    this.push(new_data)
                }
            }
    
            else if(data.id == this.secondId){
                let [j, k] = index;
                for(let i = 0; i < this.i; i++){                                    
                    let new_data = Object.assign({}, data);
                    new_data.index =  _cindex([i, k], op_step);
                    new_data.op_shape = [this.i, this.k];                    
                    new_data.tot_j = this.j;
                    new_data.j = j;
                    
                    this.push(new_data)
               
                }
            }
    
        }
    }
}


export class Reducer extends Transform{
    private waitings:{
        [index:string]:{
            tot:number[];
            count:number;
            waits:{
                [j:number]:number[];
            }
        }
    } ={}
    private frame:any|null = null;

    constructor(private firstId:number, private secondId:number){        
        super({objectMode:true, highWaterMark:1});        
    }

    _transform(data:any, e:BufferEncoding, next:TransformCallback){ 
        const key = JSON.stringify(data.iteration) + JSON.stringify(data.index);
        
        if(key in this.waitings){
            if(data.j in this.waitings[key].waits){
                
                if(data.id == this.secondId)
                    this.waitings[key].tot = this.matadd(
                        this.matmul(
                            this.waitings[key].waits[data.j],
                            data.data
                        ), this.waitings[key].tot
                    )                    
                else if(data.id == this.firstId)
                    this.waitings[key].tot = this.matadd(
                        this.matmul(
                            data.data,
                            this.waitings[key].waits[data.j]
                        ), this.waitings[key].tot
                    )

                delete this.waitings[key].waits[data.j];
                this.waitings[key].count += 1;

                if(this.waitings[key].count == data.tot_j){
                    if(this.frame){
                        this.frame.data = this.waitings[key].tot;
                        this.frame.index = data.index;
                        this.frame.iteration = data.iteration;
                        this.frame.time = data.time;
                        this.frame.outer.shape = data.op_shape;
                        this.frame.outer.step = _cstep(data.op_shape);
                        
                        delete this.frame.op_shape;
                        delete this.frame.tot_j;
                        delete this.frame.j;
                    }
                    this.push(JSON.parse(JSON.stringify(this.frame)));
                    delete this.waitings[key]                    
                }

            }else
                this.waitings[key].waits[data.j] = data.data
            
        }
        else{
            this.waitings[key] = {
                tot:data.data.map((v:number) => 0),
                count:0,
                waits:{
                    [data.j]:data.data
                }
            }

            if(!this.frame){
                this.frame = Object.assign({}, data);
                if(this.frame){
                    this.frame.data = this.frame.data.map((v:number) => 0);
                    delete this.frame.j;
                    delete this.frame.tot_j;
                }
            }
        }
        next()

    }

    matmul(a:number[], b:number[]){           
        return [
            a[0]*b[0] + a[1]*b[2],
            a[0]*b[1] + a[1]*b[3],

            a[2]*b[0] + a[3]*b[2],
            a[2]*b[1] + a[3]*b[3],
        ]
    }

    matadd(a:number[], b:number[]){      
        return a.map((v, i) => v + b[i]);
    }
}



export function matmul(a:Readable|Transform, a_id:number, b:Readable|Transform, b_id:number){
    const mapper = new Mapper(a_id, b_id);
    const reducer = new Reducer(a_id, b_id);    

    a.pipe(mapper, {end:false});
    b.pipe(mapper, {end:false});        

    mapper.pipe(reducer)
    return reducer
}



